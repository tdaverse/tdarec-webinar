---
title: "Modular, interoperable, and extensible topological data analysis in R"
author:
  - name: Jason Cory Brunson
    affiliations:
      - ref: uf
    corresponding: true
  - name: Aymeric Stamm
    affiliations: 
      - ref: lmjl
affiliations:
  - id: lmjl
    name: UMR CNRS 6629, Nantes University, Ecole Centrale de Nantes
    department: Department of Mathematics Jean Leray
    city: Nantes
    country: France
  - id: uf
    name: University of Florida
    department: Laboratory for Systems Medicine, Division of Pulmonary, Critical Care, and Sleep Medicine
    city: Gainesville
    country: United States
date: today
date-format: "YYYY MMMM D"
format:
  revealjs:
    slide-number: true
    smaller: true
    code-annotations: hover
    echo: true
    code-copy: false
revealjs-plugins:
  - drop
css: style.css
lightbox: true
---

# Introductions

:::: {.columns}

::: {.column width="40%"}

![Aymeric Stamm](images/intro-aymeric.jpg)

:::

::: {.column width="5%"}

:::

::: {.column width="42%"}

![Jason Cory Brunson](images/intro-cory.jpg)

:::

::::

# Topological Data Analysis (in R)

## What is topological data analysis?

_Topology_ is a branch of mathematics at the interface of _geometry_ and _analysis_.

::: {.fragment}
* **Geometry** is the study of rigid shapes (angle, curvature, distance).
* **Analysis** is the study of limits (continuity, smoothness).
* **Topology** is the study of properties of shapes that are invariant under continuous deformations: $$\text{Topology} \, = \, \text{Geometry} \,\, / \,\, \text{Analysis}$$
:::

## What is topological data analysis?

**Topological data analysis (TDA)** draws on principles, tools, results, and intuitions from topology to analyze data.

::: {.fragment}
TDA comprises both cutting-edge and classical techniques:

* nearest neighbor prediction
* manifold learning (Isomap, t-SNE, UMAP)
* Mapper(-like constructions)

But the core of TDA is _persistent homology_.
:::

## Persistent homology

:::: {.columns}

::: {.column width="40%"}

You've probably encountered 0-dimensional persistent homology before.

... better known as _hierarchical clustering_.

::: {.fragment}
---

See [MÃ©moli & Singhal (2019)](https://link.springer.com/article/10.1007/s11538-019-00614-z) for a theoretical primer.

![](images/title-memoli2019.jpg)
:::

:::

::: {.column width="60%"}
![Created with {ggtda} and {animate}.](images/ggtda-hclust-animation.gif)
:::

::::

## Persistent homology

:::: {.columns}

::: {.column width="40%"}
Persistent homology tracks not only

* connected components

but also

* loops (see figure),
* cells,

and

* higher-dimensional enclosures.
:::

::: {.column width="60%"}
![Created with {ggtda} and {animate}.](images/ggtda-phom-animation.gif)
:::

::::

## Applications of persistent homology

:::: {.columns}
::: {.column width="33%"}
![](images/title-ibanezmarcelo2019.jpg)
![](images/title-tymochko2020.jpg)
:::
::: {.column width="33%"}
![](images/title-leykam2022.jpg)
![](images/title-miller2023.jpg)
:::
::: {.column width="33%"}
![](images/title-conti2023.jpg)
:::
::::

### and many, many more...

Check out the Database of Original & Non-theoretical Uses of Topology (DONUT) at <https://donut.topology.rocks/>.

## Applications of PH

**diagram: needs on left, requirements on right**

(statistical inference & machine learning)
require
(local approximation & asymptotic guarantees & back-propagation)
require
(kernel density estimation & central limit theorems & vectorization)

## How can R users do TDA?

We perceive 3 types of R package for TDA:

* tool-specific (ripserr, simplextree, kernelTDA)
* analysis-specific (TDAstats, TDApplied)
* general-purpose (TDA, TDAkit, rgudhi)

Each meets certain needs, but they form a fragile ecosystem:

* duplication of methods
* hidden dependencies
* sensitivity to upgrades
* difficulty coupling

# The TDAverse

:::: {.columns}

::: {.column width="20%"}
![Raoul Wadhwa](images/team-raoul.jpg){ height=200 }
:::
::: {.column width="5%"}
:::
::: {.column width="20%"}
![Matt Piekenbrock](images/team-matt.jpg){ height=200 }
:::
::: {.column width="5%"}
:::
::: {.column width="20%"}
![James Otto](images/team-james.jpg){ height=200 }
:::

::::

## Design principles

:::: {.columns}
::: {.column width="50%"}

::: {.callout-tip title="Accessible" icon=false}  
Empower users to learn and request.

* Expressive names
* Density of examples
:::

::: {.callout-tip title="Opinionated" icon=false}  
Reduce burdens on collaborators & reviewers.

* Evidence/practice-based defaults
* Alert to any non-standard choices
:::

:::
::: {.column width="50%"}

::: {.callout-tip title="Modular" icon=false}  
Ease maintenance, contributions, and extensions.

* Different packages for different tasks
* Different packages for different steps
:::

::: {.callout-tip title="Interoperable" icon=false}  
Reduce burdens on learners & programmers.

* Unified structures & conventions
* Co-extensions with other collections
:::

:::
::::

::: {.callout-note title="Goal of the package"}

Our design principles are inspired by those of other package collections and our own experiences, in particular constraints on the availability of specialists and enthusiasts of a niche area.

:::

# Illustrations

## Engines: {TDA} and {ripserr}

TODO: Adapt demo script.

TODO: Mimic "S3 methods for persistence objects" slide.

## Upgrades

### Completed through ISC

* Substitute Ripser v1.2.1 source code for v1.0.1
* Preserve _essential pairs_ (topological features with deaths at infinity)
* Allow multivariable time series; infer sliding window duration from frequency
* Enable superlevel persistent homology of rasters

### Supported by ISC (in progress)

* Increase precision from float to double
* Alternative fields of coefficients
* Representative cycles & cocycles

## Utilities: {TDA} and {phutil}

::: {.callout-note title="Goal of the package"}
- Low-level package that defines a unifying toolbox for handling persistent homology data;
- Stands for **P**ersistent **H**omology **Util**ities.

Current features:

- A 'persistence' class to store a single persistent diagram;
- A 'persistence_set' class to store collections of persistent diagrams as a list of 'persistence' objects;
- Functions to compute distances between persistence diagrams.
:::

::: {layout-ncol="3"}
![CRAN Webpage](images/phutil-cran-annotated.png){fig-align="center" width="92%" #fig-phutil-cran}

![GitHub Repository](images/phutil-github-annotated.png){fig-align="center" width="80%" #fig-phutil-github}

![Website](images/phutil-website-annotated.png){fig-align="center" width="69%" #fig-phutil-website}
:::

## The persistence class

::: {.callout-tip title="Decision-making process"}
- What are the most common ways to represent persistent homology data? (e.g. output of various packages, but also Python libraries or C++ libraries)
- What are the most common operations on persistent homology data? (e.g. plotting, computing distances, etc.)
- What are the most common use cases? (e.g. TDA + statistical analysis)
- Trade-offs between memory efficiency, speed, and ease of use.
- Integration within machine learning pipelines.
:::

::: {.fragment}
::: {.callout-note title="Structure of the class"}

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(phutil) # <1>
```
1. The package contains data sets for demonstration and testing purposes such as `arch_spirals`, a list of 24 persistence diagrams computed from samples of points in the plane forming two interlocking spirals.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(arch_spirals[[1]]) # <2>
```
2. Each element in `arch_spirals` is of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
names(arch_spirals[[1]]) # <3>
```
3. A persistence object is a list with two elements: `pairs` and `metadata`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
str(arch_spirals[[1]]$pairs) # <4>
```
4. The `pairs` element is a list of matrices containing birth-death pairs for each homological dimension.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
str(arch_spirals[[1]]$metadata) # <5>
```
5. The `metadata` element is a list containing information about how the data was computed.
:::
:::
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] # <1>
```
1. Print a persistence object. Calls the `print()` method which in turn calls `format()`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] |> 
  as.matrix() |> # <2>
  head()
```
2. Coerce a persistence object to a matrix.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] |> 
  as.data.frame() |> # <3>
  head()
```
3. Coerce a persistence object to a data.frame.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'diagram' as produced by `TDA::*Diag()` functions to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(TDA) # <1>
```
1. Load the {TDA} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_spl <- torusUnif(300, a = 1.8, c = 5) # <2>
```
2. Sample 300 points from a torus in $R^3$.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_dgm <- ripsDiag( # <3>
  torus_spl, 
  maxdimension = 1, 
  maxscale = 2
)$diagram
```
3. Compute the Vietoris-Rips persistence diagram up to dimension 1 and scale 2.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_dgm) # <4>
```
4. The output is of class 'diagram'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(torus_dgm) # <5>
```
5. Coerce the diagram to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <6>
```
6. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <7>
```
7. Print the persistence object.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'PHom' as produced by `ripserr::vietoris_rips()` to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(ripserr) # <1>
```
1. Load the {ripserr} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_dgm <- vietoris_rips( # <2>
  torus_spl, 
  dim = 1, 
  thresh = 2
)
```
2. Compute the Vietoris-Rips persistence diagram up to dimension 1 and scale 2.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_dgm) # <3>
```
3. The output is of class 'PHom'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(torus_dgm) # <4>
```
4. Coerce the diagram to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <5>
```
5. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <6>
```
6. Print the persistence object.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'hclust' as produced by `stats::hclust()` to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(stats) # <1>
```
1. Load the {stats} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
hc <- hclust(dist(torus_spl)) # <2>
```
2. Compute a hierarchical clustering of the torus sample.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(hc) # <3>
```
3. The output is of class 'hclust'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(hc) # <4>
```
4. Coerce the hierarchical clustering to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <5>
```
5. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <6>
```
6. Print the persistence object.
:::

## Distances between persistence diagrams

The following distances between persistence diagrams have been implemented:

::: {.incremental}
- the bottleneck distance;
- the p-Wasserstein distance;
:::

illustrate via code snippets and output

dependencies: [*Hera*](https://github.com/anigmetov/hera) C++ library. The latter library is bundled within {phutil} which required a `LinkingTo` dependency on [{BH}](https://dirk.eddelbuettel.com/code/bh.html) for providing access to the Boost headers for Hera compilation.

## Recipes: {TDAvec} and {tdarec}

## Inference: {fdatest} and {inphr}

# Invitations

## Communicate

(Report bugs, request features, etc.)

TODO: Point to repo <https://github.com/tdaverse/tdaverse>

## Contribute

developer job vs user job
