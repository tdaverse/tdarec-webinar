---
title: "Modular, interoperable, and extensible topological data analysis in R"
author:
  - name: Jason Cory Brunson
    affiliations:
      - ref: uf
    corresponding: true
  - name: Aymeric Stamm
    affiliations: 
      - ref: lmjl
affiliations:
  - id: lmjl
    name: UMR CNRS 6629, Nantes University, Ecole Centrale de Nantes
    department: Department of Mathematics Jean Leray
    city: Nantes
    country: France
  - id: uf
    name: University of Florida
    department: Laboratory for Systems Medicine, Division of Pulmonary, Critical Care, and Sleep Medicine
    city: Gainesville
    country: United States
date: today
date-format: "YYYY MMMM D"
format:
  revealjs:
    slide-number: true
    smaller: true
    code-annotations: hover
    echo: true
    code-copy: false
revealjs-plugins:
  - drop
css: style.css
lightbox: true
---

# Introductions

:::: {.columns}

::: {.column width="40%"}

![Aymeric Stamm](images/intro-aymeric.jpg)

:::

::: {.column width="5%"}

:::

::: {.column width="42%"}

![Jason Cory Brunson](images/intro-cory.jpg)

:::

::::

# Topological Data Analysis (in R)

## What is topological data analysis?

_Topology_ is a branch of mathematics at the interface of _geometry_ and _analysis_.

::: {.fragment}
* **Geometry** is the study of rigid shapes (angle, curvature, distance).
* **Analysis** is the study of limits (continuity, smoothness).
* **Topology** is the study of properties of shapes that are invariant under continuous deformations: $$\text{Topology} \, = \, \text{Geometry} \,\, / \,\, \text{Analysis}$$
:::

## What is topological data analysis?

**Topological data analysis (TDA)** draws on principles, tools, results, and intuitions from topology to analyze data.

::: {.fragment}
TDA comprises both cutting-edge and classical techniques:

* cluster analysis
* nearest neighbor prediction
* Mapper(-like constructions)
* manifold learning (Isomap, t-SNE, UMAP)

But the core of TDA is _persistent homology_.
:::

## Persistent homology

:::: {.columns}

::: {.column width="40%"}

You've probably encountered 0-dimensional persistent homology before.

... better known as _hierarchical clustering_.

::: {.fragment}
---

See [MÃ©moli & Singhal (2019)](https://link.springer.com/article/10.1007/s11538-019-00614-z) for a theoretical primer that makes this precise.

![](images/title-memoli2019.jpg)
:::

:::

::: {.column width="60%"}
![Created with {ggtda} and {animate}.](images/ggtda-hclust-animation.gif)
:::

::::

## Persistent homology

:::: {.columns}

::: {.column width="40%"}
Persistent homology tracks not only

0. connected components

but also

1. loops (see figure),
2. cells,

and

3+. higher-dimensional enclosures.
:::

::: {.column width="60%"}
![Created with {ggtda} and {animate}.](images/ggtda-phom-animation.gif)
:::

::::

## Applications of PH

:::: {.columns}
::: {.column width="33%"}
![](images/title-ibanezmarcelo2019.jpg)
![](images/title-tymochko2020.jpg)
:::
::: {.column width="33%"}
![](images/title-leykam2022.jpg)
![](images/title-miller2023.jpg)
:::
::: {.column width="33%"}
![](images/title-conti2023.jpg)
:::
::::

### ... are numerous and diverse.

Check out the Database of Original & Non-theoretical Uses of Topology:

<https://donut.topology.rocks/>

## How can R users do TDA?

We see (heretofore) R packages for TDA belonging to 3 types:

* **routine-specific**<p>
  (ripserr, simplextree, kernelTDA, TDAvec)
* **analysis-specific**<p>
  (TDAstats, TDApplied, ashapesampler, lookout)
* **general-purpose**<p>
  (TDA, TDAkit, rgudhi)

Each meets certain needs, but they form a fragile ecosystem:

:::: {.columns}
::: {.column width="50%"}
* duplication of methods
* hidden dependencies
:::
::: {.column width="50%"}
* sensitivity to upgrades
* difficulty coupling
:::
::::

# The TDAverse

:::: {.columns}

::: {.column width="20%"}
![Raoul Wadhwa](images/team-raoul.jpg){ height=200 }
:::
::: {.column width="5%"}
:::
::: {.column width="20%"}
![Matt Piekenbrock](images/team-matt.jpg){ height=200 }
:::
::: {.column width="5%"}
:::
::: {.column width="20%"}
![James Otto](images/team-james.jpg){ height=200 }
:::

::::

## Design principles

:::: {.columns}
::: {.column width="50%"}

::: {.callout-tip title="Accessible" icon=false}  
Empower users to learn and request.

* Expressive names
* Density of examples
:::

::: {.callout-tip title="Opinionated" icon=false}  
Reduce burdens on collaborators & reviewers.

* Evidence/practice-based defaults
* Alert to any non-standard choices
:::

:::
::: {.column width="50%"}

::: {.callout-tip title="Modular" icon=false}  
Ease maintenance, contributions, and extensions.

* Different packages for different tasks
* Different packages for different steps
:::

::: {.callout-tip title="Interoperable" icon=false}  
Reduce burdens on learners & programmers.

* Unified structures & conventions
* Co-extensions with other collections
:::

:::
::::

These design principles are inspired by those of other package collections and by our own experiences as enthusiasts, users, and developers in a niche area.

# Illustrations

## Engines: {ripserr}

::: {.callout-note title="Goal of the package"}
- Bindings to Ripser and related C++ libraries for computing persistent homology

Current features:

- `vietoris_rips()` binding to Ripser
- `cubical()` binding to Cubical Ripser
- Helper functions to pre- and post-process data
:::

::: {layout-ncol="2"}
![](images/title-bauer2021.jpg)

![](images/title-kaji2020.jpg)
:::

## Validation and benchmark

::: {.fragment .semi-fade-out}
```{r}
#| output-location: column
#| results: hold
library(ripserr)
```
:::

TODO: Copy benchmark code.

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold

```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold

```
:::

## Use case

::: {.fragment .semi-fade-out}
```{r}
#| output-location: column
#| results: hold
str(ldeaths)
frequency(ldeaths)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
#| fig-height: 2.5
#| echo: 2
op <- par(mar = c(2, 4, 2, 2) + 0.1)
plot(ldeaths, xlab = NULL)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
ldeaths_swe <- 
  ripserr:::numeric_vector_to_quasi_attractor(
    ldeaths,
    data_dim = 12, dim_lag = 1, sample_lag = 1
  )
ldeaths_pca <- prcomp(ldeaths_swe)$x
( ldeaths_ph <- vietoris_rips(ldeaths) )
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
#| echo: !expr c(2,3)
par(mfrow = c(1, 2), mar = c(2, 4, 2, 2) + 0.1)
plot(ldeaths_pca[, 1:2], asp = 1)
TDA:::plot.diagram(ldeaths_ph, asp = 1)
```
:::

## Upgrades

### Completed through ISC

* Replace Ripser v1.0.1 with v1.2.1
* Preserve _essential pairs_ (topological features with deaths at infinity)
* Handle multivariable time series

### Supported by ISC (in progress)

* Increase precision from float to double
* Alternative fields of coefficients
* Representative cycles & cocycles

## Research Assistants

Bindings, enhancements, and other contributions by **Kent Phipps**, **Sean Hershkowitz**, and **Alice Zhang**.

![](images/certificates.jpeg){width=600 fig-align="center"}

## Utilities: {phutil}

::: {.callout-note title="Goal of the package"}
- Low-level package that defines a unifying toolbox for handling persistent homology data;
- Stands for **P**ersistent **H**omology **Util**ities.

Current features:

- A 'persistence' class to store a single persistent diagram;
- A 'persistence_set' class to store collections of persistent diagrams as a list of 'persistence' objects;
- Functions to compute distances between persistence diagrams.
:::

::: {layout-ncol="3"}
![CRAN Webpage](images/phutil-cran-annotated.png){fig-align="center" width="92%" #fig-phutil-cran}

![GitHub Repository](images/phutil-github-annotated.png){fig-align="center" width="80%" #fig-phutil-github}

![Website](images/phutil-website-annotated.png){fig-align="center" width="69%" #fig-phutil-website}
:::

## The persistence class

::: {.callout-tip title="Decision-making process"}
- What are the most common ways to represent persistent homology data? (e.g. output of various packages, but also Python libraries or C++ libraries)
- What are the most common operations on persistent homology data? (e.g. plotting, computing distances, etc.)
- What are the most common use cases? (e.g. TDA + statistical analysis)
- Trade-offs between memory efficiency, speed, and ease of use.
- Integration within machine learning pipelines.
:::

::: {.fragment}
::: {.callout-note title="Structure of the class"}

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(phutil) # <1>
```
1. The package contains data sets for demonstration and testing purposes such as `arch_spirals`, a list of 24 persistence diagrams computed from samples of points in the plane forming two interlocking spirals.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(arch_spirals[[1]]) # <2>
```
2. Each element in `arch_spirals` is of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
names(arch_spirals[[1]]) # <3>
```
3. A persistence object is a list with two elements: `pairs` and `metadata`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
str(arch_spirals[[1]]$pairs) # <4>
```
4. The `pairs` element is a list of matrices containing birth-death pairs for each homological dimension.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
str(arch_spirals[[1]]$metadata) # <5>
```
5. The `metadata` element is a list containing information about how the data was computed.
:::
:::
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] # <1>
```
1. Print a persistence object. Calls the `print()` method which in turn calls `format()`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] |> 
  as.matrix() |> # <2>
  head()
```
2. Coerce a persistence object to a matrix.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] |> 
  as.data.frame() |> # <3>
  head()
```
3. Coerce a persistence object to a data.frame.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'diagram' as produced by `TDA::*Diag()` functions to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(TDA) # <1>
```
1. Load the {TDA} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_spl <- torusUnif(300, a = 1.8, c = 5) # <2>
```
2. Sample 300 points from a torus in $R^3$.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_dgm <- ripsDiag( # <3>
  torus_spl, 
  maxdimension = 1, 
  maxscale = 2
)$diagram
```
3. Compute the Vietoris-Rips persistence diagram up to dimension 1 and scale 2.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_dgm) # <4>
```
4. The output is of class 'diagram'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(torus_dgm) # <5>
```
5. Coerce the diagram to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <6>
```
6. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <7>
```
7. Print the persistence object.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'PHom' as produced by `ripserr::vietoris_rips()` to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(ripserr) # <1>
```
1. Load the {ripserr} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_dgm <- vietoris_rips( # <2>
  torus_spl, 
  dim = 1, 
  thresh = 2
)
```
2. Compute the Vietoris-Rips persistence diagram up to dimension 1 and scale 2.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_dgm) # <3>
```
3. The output is of class 'PHom'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(torus_dgm) # <4>
```
4. Coerce the diagram to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <5>
```
5. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <6>
```
6. Print the persistence object.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'hclust' as produced by `stats::hclust()` to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(stats) # <1>
```
1. Load the {stats} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
hc <- hclust(dist(torus_spl)) # <2>
```
2. Compute a hierarchical clustering of the torus sample.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(hc) # <3>
```
3. The output is of class 'hclust'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(hc) # <4>
```
4. Coerce the hierarchical clustering to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <5>
```
5. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <6>
```
6. Print the persistence object.
:::

## Distances between persistence diagrams

The following distances between persistence diagrams have been implemented:

::: {.incremental}
- the bottleneck distance;
- the p-Wasserstein distance;
:::

illustrate via code snippets and output

dependencies: [*Hera*](https://github.com/anigmetov/hera) C++ library. The latter library is bundled within {phutil} which required a `LinkingTo` dependency on [{BH}](https://dirk.eddelbuettel.com/code/bh.html) for providing access to the Boost headers for Hera compilation.

## Recipes: {tdarec}

::: {.callout-note title="Goal of the package"}
- Tidymodels extension for persistent homology and its vectorizations

Current features:

- {ripserr}-powered recipe steps to compute persistent homology from data
- {TDAvec}-powered recipe steps to compute numeric features from persistent diagrams
- Miscellaneous related pre-processing steps
- Tunable dials for parameters governing the above
:::

::: {layout-ncol="2"}
![](images/tdarec-readme.png)

![](images/tdarec-vignette.png)
:::

## Recipe steps

::: {.fragment .semi-fade-out}
```{r}
#| output-location: column
#| results: hold
library(ripserr)
library(tidymodels)
library(tdarec)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
#| echo: !expr c(2,3)
op <- par(mfrow = c(1, 2), mar = c(1, 1, 1, 1) + 0.1)
image(powehi, 
  col = hcl.colors(
    256, palette = "inferno", alpha = NULL,
    rev = FALSE, fixup = TRUE
  ), axes = FALSE, asp = 1)
image(sagAstar, 
  col = hcl.colors(
    256, palette = "inferno", alpha = NULL,
    rev = FALSE, fixup = TRUE
  ), axes = FALSE, asp = 1)
par(op)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
blackholes <- tibble(
  name = c("Powehi", "Sgr A*"),
  img = list(powehi, sagAstar)
)
recipe(name ~ ., data = blackholes) |> 
  update_role(img, new_role = "raw data") |> 
  print() -> bh_rec0
bh_rec0 |> 
  prep() |> 
  bake(new_data = blackholes)
```
:::

## Recipe steps

::: {.fragment .semi-fade-out}
```{r}
#| output-location: column
#| results: hold
( bh_rec1 <- step_pd_raster(bh_rec0, img) )
bh_rec1 |> 
  prep() |> 
  bake(new_data = blackholes)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
#| echo: !expr c(2,3,4)
op <- par(mfrow = c(1, 2), mar = c(2, 4, 2, 2) + 0.1)
bh_bake1 <- bake(prep(bh_rec1), new_data = blackholes)
TDA:::plot.diagram(bh_bake1$img[[1]], asp = 1)
TDA:::plot.diagram(bh_bake1$img[[2]], asp = 1)
par(op)
```
:::

## Recipe steps

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
bh_rec2 <- step_vpd_tent_template_functions(
  bh_rec1, img,
  hom_degree = 1, tent_shift = tune()
)
bh_rec2 |> 
  finalize_recipe(list(tent_shift = 10)) |> 
  prep() |> 
  bake(new_data = blackholes)
```
:::

## Tunable dials

::: {.fragment .semi-fade-out}
```{r}
#| output-location: column
#| results: hold
extract_parameter_set_dials(bh_rec1)
extract_parameter_set_dials(bh_rec2)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
ts_fin <- finalize(
  tent_shift(),
  prep(bh_rec1) |> 
    bake(new_data = blackholes) |> 
    select(img)
)
print(ts_fin)
```
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
grid_regular(ts_fin, levels = 5)
```
:::

## Collaborators

**Umar Islambekov** and **Aleksei Luchinsky** coordinated development of {TDAvec} with the scope and needs of {tdarec}.

:::: {.columns}
::: {.column width="10%"}
:::
::: {.column width="30%"}
![](images/team-umar.jpg){ height=300 }
:::
::: {.column width="10%"}
:::
::: {.column width="30%"}
![](images/team-aleksei.jpeg){ height=300 }
:::
::: {.column width="10%"}
:::
::::

## Inference: {inphr}

# Invitations

## Communicate

(Report bugs, request features, etc.)

TODO: Point to repo <https://github.com/tdaverse/tdaverse>

## Contribute

developer job vs user job
