---
title: "Modular, interoperable, and extensible topological data analysis in R"
author:
  - name: Jason Cory Brunson
    affiliations:
      - ref: uf
    corresponding: true
  - name: Aymeric Stamm
    affiliations: 
      - ref: lmjl
affiliations:
  - id: lmjl
    name: UMR CNRS 6629, Nantes University, Ecole Centrale de Nantes
    department: Department of Mathematics Jean Leray
    city: Nantes
    country: France
  - id: uf
    name: University of Florida
    department: Laboratory for Systems Medicine, Division of Pulmonary, Critical Care, and Sleep Medicine
    city: Gainesville
    country: United States
date: today
date-format: "YYYY MMMM D"
format:
  revealjs:
    slide-number: true
    smaller: true
    code-annotations: hover
    echo: true
    code-copy: false
revealjs-plugins:
  - drop
css: style.css
lightbox: true
---

# Introductions

# Topological Data Analysis (in R)

## What is topological data analysis?

_Topology_ is a branch of mathematics at the interface of _geometry_ and _analysis_.

* **Geometry** is the study of rigid shapes (angle, curvature, distance).
* **Analysis** is the study of continuity (limits).
* **Topology** is the study of properties of shapes that are invariant under continuous deformations: $$\text{Topology} \, = \, \text{Geometry} \,\, / \,\, \text{Analysis}$$

**Topological data analysis (TDA)** draws on principles, tools, results, and intuitions from topology to analyze data.

TDA may be understood to comprise many diverse, and some classical techniques:

* shape-preserving subsampling
* nearest neighbor prediction
* manifold learning (Isomap, t-SNE, UMAP)
* discrete morse theory
* Mapper(-like constructions)

But the core of TDA is _persistent homology_.

## Persistent homology

Text.

:::: {.columns}



::: {.column width="40%"}

:::

::: {.column width="40%"}

(Inset the {ggtda} animation.)

:::

::::

## Applications of PH

**(examples from previous presentation)**

### and many, many more...

Check out the Database of Original & Non-theoretical Uses of Topology (DONUT) at <https://donut.topology.rocks/>.

## Applications of PH

**diagram: needs on left, requirements on right**

(statistical inference & machine learning)
require
(local approximation & asymptotic guarantees & back-propagation)
require
(kernel density estimation & central limit theorems & vectorization)

## How can R users do TDA?

unitl recently (and my impression), 3 bins:

* tool-specific (ripserr, simplextree, kernelTDA)
* analysis-specific (TDAstats, TDApplied)
* general-purpose (TDA, TDAkit)

problems

* sensitive to upgrades
* independent (not designed to be interoperable)
* hidden, hence duplicated, dependencies

# The TDAverse

## Design principles

**Accessible**: Show, don't tell.

Why?

- Minimize user pain.
- Improve user feedback.
- Empower new developers.

How?

- Use expressive function and argument names.
- Cram packages with examples and vignettes.
- Document for contribution as well as use.

**Opinionated**: Induce good practice.

Why?

- Improve the quality and reliability of work.
- Reduce burdens on reviewers.

How?

- Adopt appropriate defaults.
- Make standard operations and recommended choices less effortful.

**Modular**: Do one thing, and do it well.

Why?

- Make packages easier to maintain and upgrade.
- Contain disruptions due to upgrades and breaking changes.

How?

- Put unrelated routines and separable analysis steps in different packages.
- Limit each package to one "tier" (computational tool, analysis procedure, extension).

**Extensible**:

Why?

- Ease incorporation of new methods.
- Reduce burdens on developers.

How?

- Adopt shared standards.
- State and justify the scope of each package.

**Interoperable**: 

Why?

- Reduce burdens on learners & users.
- Enable efficient workflows.

How?

- Unify structures and conventions across packages.
- Co-extend with other package collections (tidyverse, tidymodels, mlr3).

::: {.callout-note title="Goal of the package"}

Our design principles are inspired by those of other package collections and our own experiences, in particular constraints on the availability of specialists and enthusiasts of a niche area.

:::

## Past & Future

:::: {.columns}

::: {.column width="40%"}

### Timeline

**2018**

- RW publishes {TDAstats}, reviewed by JCB
- MP writes {Mapper}

**2019**

- RW and JCB write {ggtda}

**2020**

- RW spins {ripserr} off {TDAstats}
- MP spins {simplextree} off {Mapper}
- JCB authors {tdaunif}

**2021**

- RW presents at ????

**2022**

- JCB presents at useR!
- RW, MP, and JCB inaugurate the "TDAverse"
- JO writes {TDAvis}
- RW, JCB, and JO combine {ggtda} and {TDAvis}

**2023**

- AS publishes {rgudhi}

**2024**

- JCB and AS request & receive R Consortium support for {tdarec} & {inphr}

:::

::: {.column width="40%"}

### Aspirations (MOVE THIS TO END?)

**Packages in development**

- {ggtda}: {ggplot2} extension for persistence data
- {plt}: binding to the `Persistence Landscapes Toolbox` C++ library
- {rgp}: binding to the `ReebGraphPairing` Java program
- {landmark}: shape-preserving subsampling methods

**Packages in incubation**

- {pheng}: engine deployment for persistent homology
- {phrou}: bindings to common routines

**Packages in limbo**

- {Mapper}: R6 classes for mapper constructions
- {Cover}: R6 classes for topological covers

:::

::::

# Illustrations

## Engines: {TDA} and {ripserr}

(Adapt demo script.)

## Upgrades

### Completed through ISC

* Substitute Ripser v1.2.1 source code for v1.0.1
* Preserve _essential pairs_ (topological features with deaths at infinity)
* Allow multivariable time series; infer sliding window duration from frequency
* Enable superlevel persistent homology of rasters

### Supported by ISC (in progress)

* Increase precision from float to double
* Alternative fields of coefficients
* Representative cycles & cocycles

## Utilities: {TDA} and {phutil}

::: {.callout-note title="Goal of the package"}
- Low-level package that defines a unifying toolbox for handling persistent homology data;
- Stands for **P**ersistent **H**omology **Util**ities.

Current features:

- A 'persistence' class to store a single persistent diagram;
- A 'persistence_set' class to store collections of persistent diagrams as a list of 'persistence' objects;
- Functions to compute distances between persistence diagrams.
:::

::: {layout-ncol="3"}
![CRAN Webpage](images/phutil-cran-annotated.png){fig-align="center" width="92%" #fig-phutil-cran}

![GitHub Repository](images/phutil-github-annotated.png){fig-align="center" width="80%" #fig-phutil-github}

![Website](images/phutil-website-annotated.png){fig-align="center" width="69%" #fig-phutil-website}
:::

## The persistence class

::: {.callout-tip title="Decision-making process"}
- What are the most common ways to represent persistent homology data? (e.g. output of various packages, but also Python libraries or C++ libraries)
- What are the most common operations on persistent homology data? (e.g. plotting, computing distances, etc.)
- What are the most common use cases? (e.g. TDA + statistical analysis)
- Trade-offs between memory efficiency, speed, and ease of use.
- Integration within machine learning pipelines.
:::

::: {.fragment}
::: {.callout-note title="Structure of the class"}

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(phutil) # <1>
```
1. The package contains data sets for demonstration and testing purposes such as `arch_spirals`, a list of 24 persistence diagrams computed from samples of points in the plane forming two interlocking spirals.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(arch_spirals[[1]]) # <2>
```
2. Each element in `arch_spirals` is of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
names(arch_spirals[[1]]) # <3>
```
3. A persistence object is a list with two elements: `pairs` and `metadata`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
str(arch_spirals[[1]]$pairs) # <4>
```
4. The `pairs` element is a list of matrices containing birth-death pairs for each homological dimension.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
str(arch_spirals[[1]]$metadata) # <5>
```
5. The `metadata` element is a list containing information about how the data was computed.
:::
:::
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] # <1>
```
1. Print a persistence object. Calls the `print()` method which in turn calls `format()`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] |> 
  as.matrix() |> # <2>
  head()
```
2. Coerce a persistence object to a matrix.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
arch_spirals[[1]] |> 
  as.data.frame() |> # <3>
  head()
```
3. Coerce a persistence object to a data.frame.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'diagram' as produced by `TDA::*Diag()` functions to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(TDA) # <1>
```
1. Load the {TDA} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_spl <- torusUnif(300, a = 1.8, c = 5) # <2>
```
2. Sample 300 points from a torus in $R^3$.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_dgm <- ripsDiag( # <3>
  torus_spl, 
  maxdimension = 1, 
  maxscale = 2
)$diagram
```
3. Compute the Vietoris-Rips persistence diagram up to dimension 1 and scale 2.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_dgm) # <4>
```
4. The output is of class 'diagram'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(torus_dgm) # <5>
```
5. Coerce the diagram to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <6>
```
6. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <7>
```
7. Print the persistence object.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'PHom' as produced by `ripserr::vietoris_rips()` to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(ripserr) # <1>
```
1. Load the {ripserr} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_dgm <- vietoris_rips( # <2>
  torus_spl, 
  dim = 1, 
  thresh = 2
)
```
2. Compute the Vietoris-Rips persistence diagram up to dimension 1 and scale 2.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_dgm) # <3>
```
3. The output is of class 'PHom'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(torus_dgm) # <4>
```
4. Coerce the diagram to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <5>
```
5. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <6>
```
6. Print the persistence object.
:::

## S3 methods for persistence objects

Dependencies: {cli} for pretty printing.

We can coerce objects of class 'hclust' as produced by `stats::hclust()` to class `persistence`:

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
library(stats) # <1>
```
1. Load the {stats} package.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
hc <- hclust(dist(torus_spl)) # <2>
```
2. Compute a hierarchical clustering of the torus sample.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(hc) # <3>
```
3. The output is of class 'hclust'.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers <- as_persistence(hc) # <4>
```
4. Coerce the hierarchical clustering to class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
class(torus_pers) # <5>
```
5. The output is now of class `persistence`.
:::

::: {.fragment .fade-in-then-semi-out}
```{r}
#| output-location: column
#| results: hold
torus_pers # <6>
```
6. Print the persistence object.
:::

## Distances between persistence diagrams

The following distances between persistence diagrams have been implemented:

::: {.incremental}
- the bottleneck distance;
- the p-Wasserstein distance;
:::

illustrate via code snippets and output

dependencies: [*Hera*](https://github.com/anigmetov/hera) C++ library. The latter library is bundled within {phutil} which required a `LinkingTo` dependency on [{BH}](https://dirk.eddelbuettel.com/code/bh.html) for providing access to the Boost headers for Hera compilation.

## Recipes: {TDAvec} and {tdarec}

## Inference: {fdatest} and {inphr}

# Invitations

## Communicate

(Report bugs, request features, etc.)

## Contribute
